import heapq

# ---------------------------------------------
# Heuristic Function: number of people left / 2
# ---------------------------------------------
def heuristic(state):
    M_left, C_left, _ = state
    return (M_left + C_left) // 2  # estimate: min trips remaining


# ---------------------------------------------
# Check if state is valid (missionaries not eaten)
# ---------------------------------------------
def is_valid(state):
    M_left, C_left, boat = state
    M_right, C_right = 3 - M_left, 3 - C_left

    # Out of bounds check
    if not (0 <= M_left <= 3 and 0 <= C_left <= 3):
        return False

    # Missionaries not eaten
    if (M_left > 0 and C_left > M_left) or (M_right > 0 and C_right > M_right):
        return False

    return True


# ---------------------------------------------
# Generate possible next states
# ---------------------------------------------
def get_successors(state):
    successors = []
    M_left, C_left, boat = state

    moves = [(1, 0), (2, 0), (0, 1), (0, 2), (1, 1)]  # possible moves

    for M_move, C_move in moves:
        if boat == 'L':
            new_state = (M_left - M_move, C_left - C_move, 'R')
        else:
            new_state = (M_left + M_move, C_left + C_move, 'L')

        if is_valid(new_state):
            successors.append(new_state)
    return successors


# ---------------------------------------------
# Reconstruct the path
# ---------------------------------------------
def reconstruct_path(parents, current):
    path = [current]
    while current in parents:
        current = parents[current]
        path.append(current)
    return path[::-1]


# ---------------------------------------------
# A* Search Algorithm
# ---------------------------------------------
def a_star(start, goal):
    pq = []
    heapq.heappush(pq, (heuristic(start), 0, start))  # (f, g, state)
    g_cost = {start: 0}
    parents = {}

    while pq:
        f, g, current = heapq.heappop(pq)

        if current == goal:
            return reconstruct_path(parents, current)

        for neighbor in get_successors(current):
            new_g = g + 1
            f_val = new_g + heuristic(neighbor)
            if neighbor not in g_cost or new_g < g_cost[neighbor]:
                g_cost[neighbor] = new_g
                parents[neighbor] = current
                heapq.heappush(pq, (f_val, new_g, neighbor))

    return None


# ---------------------------------------------
# Display path in readable form
# ---------------------------------------------
def print_path(path):
    print("\n--- Solution Path ---\n")
    for step, state in enumerate(path):
        M_left, C_left, boat = state
        M_right, C_right = 3 - M_left, 3 - C_left
        print(f"Step {step}:")
        print(f"Left Bank:  M={M_left}, C={C_left}  |  Boat: {boat}  |  Right Bank: M={M_right}, C={C_right}\n")


# ---------------------------------------------
# MAIN
# ---------------------------------------------
if __name__ == "__main__":
    start_state = (3, 3, 'L')
    goal_state = (0, 0, 'R')

    print("Missionaries and Cannibals Problem using A* Search\n")
    path = a_star(start_state, goal_state)

    if path:
        print_path(path)
        print("✅ Goal Reached in", len(path) - 1, "steps!")
    else:
        print("❌ No solution found.")
